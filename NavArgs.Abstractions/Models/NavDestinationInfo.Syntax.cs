using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using static NavArgs.Abstractions.Constants;

namespace NavArgs.Abstractions.Models;

internal partial record NavDestinationInfo
{
    private const string FromDictionaryName = "FromDictionary";
    private const string ToDictionaryName = "ToDictionary";
    private const string GetArgsName = "GetArgs";
    private const string DictionaryVariable = "dictionary";

    // ReSharper disable once InconsistentNaming
    private const string IDictionaryType = "IDictionary";
    private const string DictionaryType = "Dictionary";
    private const string AutoGenerated = "// <auto-generated/>";

    public CompilationUnitSyntax GetCompilationUnit()
    {
        var usingsDeclaration = List<UsingDirectiveSyntax>([
            UsingDirective(ParseName("System")),
            UsingDirective(ParseName("System.Collections.Generic")),
            UsingDirective(ParseName(Constants.Namespace)),
        ]);

        MemberDeclarationSyntax[] classDeclarations =
        [
            PartialClassDeclaration(this),
            ArgsRecordDeclaration(this)
        ];

        MemberDeclarationSyntax[] members;
        if (string.IsNullOrEmpty(Namespace))
        {
            members = classDeclarations;
        }
        else
        {
            members =
            [
                NamespaceDeclaration(IdentifierName(Namespace))
                    .AddMembers(classDeclarations)
            ];
        }

        return CompilationUnit()
            .WithUsings(usingsDeclaration)
            .AddMembers(members)
            .WithLeadingTrivia(TriviaList(
                Comment(AutoGenerated),
                Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true))
            ))
            .NormalizeWhitespace();
    }

    private static ClassDeclarationSyntax PartialClassDeclaration(NavDestinationInfo info)
    {
        MemberDeclarationSyntax[] membersList;
        var useRoute = !string.IsNullOrWhiteSpace(info.Route);
        if (useRoute)
        {
            membersList =
            [
                RoutePropertyDeclaration(info.Route!),
                GetArgsMethodDeclaration(info),
                ToDictionaryMethodDeclaration(info.Properties),
            ];
        }
        else
        {
            membersList =
            [
                GetArgsMethodDeclaration(info),
                ToDictionaryMethodDeclaration(info.Properties),
            ];
        }

        var members = List(membersList);

        if (useRoute)
        {
            members.Add(RoutePropertyDeclaration(info.Route!));
        }

        return ClassDeclaration(info.QualifiedName)
            .WithMembers(members)
            .WithModifiers(TokenList(
                Token(SyntaxKind.PartialKeyword)
            ));
    }

    private static RecordDeclarationSyntax ArgsRecordDeclaration(NavDestinationInfo info)
    {
        var qualifiedName = info.GetArgsClassName();

        var baseTypes = BaseList(SeparatedList<BaseTypeSyntax>(
        [
            SimpleBaseType(ParseTypeName(ArgsInterfaceName))
        ]));

        MemberDeclarationSyntax[] methodsDeclaration =
        [
            FromDictionaryMethodDeclaration(qualifiedName, info.Properties),
            // ToDictionaryMethodDeclaration(info.Properties),
        ];

        var parametersList = ParameterList(
            SeparatedList(info.Properties.Select(p =>
                Parameter(Identifier(p.Name)).WithType(ParseTypeName(p.GetValidTypeName())))));

        var recordDeclaration =
            RecordDeclaration(Token(SyntaxKind.RecordKeyword), Identifier(qualifiedName))
                .WithBaseList(baseTypes)
                .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
                .WithParameterList(parametersList)
                .WithMembers(List(methodsDeclaration))
                .WithOpenBraceToken(Token(SyntaxKind.OpenBraceToken))
                .WithCloseBraceToken(Token(SyntaxKind.CloseBraceToken))
                .WithLeadingTrivia(TriviaList(Comment(AutoGenerated)))
                .NormalizeWhitespace();

        return recordDeclaration;
    }

    private static MethodDeclarationSyntax ToDictionaryMethodDeclaration(ImmutableArray<PropertyInfo> properties)
    {
        var assignmentExpressions =
            properties.Select(p => AssignmentExpression(
                    SyntaxKind.SimpleAssignmentExpression,
                    left: ImplicitElementAccess(
                        BracketedArgumentList(
                            SingletonSeparatedList(
                                Argument(InvocationExpression(
                                        IdentifierName("nameof"),
                                        ArgumentList(
                                            SingletonSeparatedList(Argument(IdentifierName(p.Name)))
                                        )
                                    )
                                )
                            )
                        )
                    ),
                    right: MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        ThisExpression(),
                        IdentifierName(p.Name)
                    )
                )
            ).ToArray();

        var dictionaryCreation = ObjectCreationExpression(
            GenericName(
                Identifier(DictionaryType),
                TypeArgumentList(
                    SeparatedList<TypeSyntax>(
                        [
                            PredefinedType(Token(SyntaxKind.StringKeyword)),
                            NullableType(PredefinedType(Token(SyntaxKind.ObjectKeyword))),
                        ]
                    )
                )
            ), ArgumentList(SeparatedList<ArgumentSyntax>()),
            InitializerExpression(SyntaxKind.ObjectInitializerExpression,
                SeparatedList<ExpressionSyntax>(assignmentExpressions))
        );

        var returnStatement = ReturnStatement(dictionaryCreation);

        var method = MethodDeclaration(
                GenericName(
                    Identifier(IDictionaryType),
                    TypeArgumentList(SeparatedList<TypeSyntax>([
                        PredefinedType(Token(SyntaxKind.StringKeyword)),
                        NullableType(PredefinedType(Token(SyntaxKind.ObjectKeyword)))
                    ]))
                ),
                Identifier(ToDictionaryName)
            ).WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
            .WithBody(Block(returnStatement));
        return method;
    }

    private static MethodDeclarationSyntax FromDictionaryMethodDeclaration(string instanceType,
        ImmutableArray<PropertyInfo> properties)
    {
        var arguments = SeparatedList(
            properties.Select(p => Argument(DictionaryAccessAndCastArgument(p)))
        );
        var instanceCreation = ArgsInstanceCreation(instanceType, arguments);
        var returnStatement = ReturnStatement(instanceCreation);

        var parameters =
            ParameterList(
                SingletonSeparatedList(
                    Parameter(Identifier(DictionaryVariable))
                        .WithType(
                            GenericName(
                                Identifier(IDictionaryType),
                                TypeArgumentList(SeparatedList<TypeSyntax>([
                                    PredefinedType(Token(SyntaxKind.StringKeyword)),
                                    PredefinedType(Token(SyntaxKind.ObjectKeyword))
                                ]))
                            )
                        )
                )
            );

        return MethodDeclaration(ParseTypeName(instanceType), Identifier(FromDictionaryName))
            .WithModifiers(TokenList(
                Token(SyntaxKind.PublicKeyword),
                Token(SyntaxKind.StaticKeyword)
            ))
            .WithParameterList(parameters)
            .WithBody(Block(returnStatement));
    }

    private static ObjectCreationExpressionSyntax ArgsInstanceCreation(string instanceType,
        SeparatedSyntaxList<ArgumentSyntax> arguments)
    {
        var objectCreation = ObjectCreationExpression(
            type: ParseTypeName(instanceType),
            argumentList: ArgumentList(arguments),
            initializer: null);

        return objectCreation;
    }

    private static ExpressionSyntax DictionaryAccessAndCastArgument(PropertyInfo property)
    {
        // dictionary[nameof(propertyName)]
        var dictionaryAccess = ElementAccessExpression(IdentifierName(DictionaryVariable),
            BracketedArgumentList(
                SingletonSeparatedList(
                    Argument(InvocationExpression(
                            IdentifierName("nameof"),
                            ArgumentList(SingletonSeparatedList(Argument(IdentifierName(property.Name))))
                        )
                    )
                )
            ));

        ExpressionSyntax expression;

        // TODO: I'm struggling in this part. I'm trying to make so that if the property is simple (primitive or string) and its not nullable then the cast is normal 
        //  If the property is simple but nullable then it could be with "as" or normal cast, but the type to cast should be the nullable annotated
        //  But when it is complex type then it should always allow nullable, so it would be with "as" but the type would not be the nullable annotated
        if (property.IsSimple)
        {
            expression = CastExpression(
                type: ParseTypeName(property.TypeName),
                expression: dictionaryAccess);
        }
        else
        {
            expression = BinaryExpression(SyntaxKind.AsExpression,
                left: dictionaryAccess,
                // right: ParseTypeName(property.GetValidTypeName()),
                right: ParseTypeName("onject"),
                operatorToken: Token(SyntaxKind.AsKeyword));
        }
        

        return expression.NormalizeWhitespace();
    }

    private static MethodDeclarationSyntax GetArgsMethodDeclaration(NavDestinationInfo info)
    {
        var arguments = SeparatedList(
            info.Properties.Select(p =>
                Argument(
                    IdentifierName(p.Name)
                    // MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                    //     ThisExpression(),
                    //     IdentifierName(p.Name))
                )
            ));
        var argsCreation = ArgsInstanceCreation(info.GetArgsClassName(), arguments);

        var returnStatement = ReturnStatement(argsCreation);
        var method = MethodDeclaration(ParseTypeName(ArgsInterfaceName), Identifier(GetArgsName))
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
            .WithBody(Block(returnStatement));
        return method;
    }

    private static PropertyDeclarationSyntax RoutePropertyDeclaration(string route)
    {
        return PropertyDeclaration(PredefinedType(Token(SyntaxKind.StringKeyword)), Identifier("Route"))
            .AddModifiers(Token(SyntaxKind.PublicKeyword))
            .WithExpressionBody(
                ArrowExpressionClause(Token(SyntaxKind.EqualsGreaterThanToken),
                    LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(route))
                )
            ).WithSemicolonToken(Token(SyntaxKind.SemicolonToken));
    }
}