using System.CodeDom.Compiler;
using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using static NavArgs.Abstractions.Constants;

namespace NavArgs.Abstractions.Models;

internal partial record NavDestinationInfo
{
    private const string FromDictionaryName = "FromDictionary";
    private const string ToDictionaryName = "ToDictionary";
    private const string GetArgsName = "GetArgs";
    private const string DictionaryVariable = "dictionary";

    // ReSharper disable once InconsistentNaming
    private const string IDictionaryType = "IDictionary";

    private const string DictionaryType = "Dictionary";

    // private const string InstanceVariable = "instance";
    private const string AutoGenerated = "// <auto-generated/>";

    private static readonly string CodeGenName;
    private static readonly string CodeGenVersion;

    static NavDestinationInfo()
    {
        var assembly = typeof(NavDestinationInfo).Assembly;
        CodeGenName = assembly.GetName().Name;
        CodeGenVersion = assembly.GetName().Version.ToString();
    }

    public CompilationUnitSyntax GetCompilationUnit()
    {
        var usingsDeclaration = List<UsingDirectiveSyntax>([
            UsingDirective(ParseName("System")),
            UsingDirective(ParseName("System.Collections.Generic")),
            UsingDirective(ParseName(Constants.Namespace))
        ]);

        MemberDeclarationSyntax[] classDeclarations =
        [
            PartialClassDeclaration(this),
            ArgsRecordDeclaration(this)
        ];

        MemberDeclarationSyntax[] members;
        if (string.IsNullOrEmpty(Namespace))
            members = classDeclarations;
        else
            members =
            [
                NamespaceDeclaration(IdentifierName(Namespace))
                    .AddMembers(classDeclarations)
            ];

        return CompilationUnit()
            .WithUsings(usingsDeclaration)
            .AddMembers(members)
            .WithLeadingTrivia(TriviaList(
                Comment(AutoGenerated),
                Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true))
            ))
            .NormalizeWhitespace();
    }

    private static ClassDeclarationSyntax PartialClassDeclaration(NavDestinationInfo info)
    {
        MemberDeclarationSyntax[] membersList;
        var useRoute = !string.IsNullOrWhiteSpace(info.Route);
        if (useRoute)
            membersList =
            [
                RoutePropertyDeclaration(info.Route!),
                GetArgsMethodDeclaration(info),
                ToDictionaryMethodDeclaration(info.Properties)
            ];
        else
            membersList =
            [
                GetArgsMethodDeclaration(info),
                ToDictionaryMethodDeclaration(info.Properties)
            ];

        var members = List(membersList);

        if (useRoute) members.Add(RoutePropertyDeclaration(info.Route!));

        return ClassDeclaration(info.QualifiedName)
            .WithMembers(members)
            .WithModifiers(TokenList(
                Token(SyntaxKind.PartialKeyword)
            ))
            .AddAttributeLists(GetAttributesList(GeneratorAttribute()))
            .WithLeadingTrivia(TriviaList(Comment(AutoGenerated)))
            .NormalizeWhitespace();
    }

    private static RecordDeclarationSyntax ArgsRecordDeclaration(NavDestinationInfo info)
    {
        var baseTypes = BaseList(SeparatedList<BaseTypeSyntax>(
        [
            SimpleBaseType(ParseTypeName(ArgsInterfaceName))
        ]));

        MemberDeclarationSyntax[] methodsDeclaration =
        [
            FromDictionaryMethodDeclaration(info)
            // ToDictionaryMethodDeclaration(info.Properties),
        ];

        var parametersList = ParameterList(
            SeparatedList(info.Properties.Select(p =>
                Parameter(Identifier(p.Name)).WithType(ParseTypeName(p.Type)))));

        var recordDeclaration =
            RecordDeclaration(Token(SyntaxKind.RecordKeyword), Identifier(info.GetArgsClassName()))
                .WithBaseList(baseTypes)
                .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
                .WithParameterList(parametersList)
                .WithMembers(List(methodsDeclaration))
                .WithOpenBraceToken(Token(SyntaxKind.OpenBraceToken))
                .WithCloseBraceToken(Token(SyntaxKind.CloseBraceToken))
                .AddAttributeLists(GetAttributesList(GeneratorAttribute()))
                .WithLeadingTrivia(TriviaList(Comment(AutoGenerated)))
                .NormalizeWhitespace();

        return recordDeclaration;
    }

    private static MethodDeclarationSyntax ToDictionaryMethodDeclaration(ImmutableArray<PropertyInfo> properties)
    {
        var assignmentExpressions =
            properties.Select(p => AssignmentExpression(
                    SyntaxKind.SimpleAssignmentExpression,
                    ImplicitElementAccess(
                        BracketedArgumentList(
                            SingletonSeparatedList(
                                Argument(InvocationExpression(
                                        IdentifierName("nameof"),
                                        ArgumentList(
                                            SingletonSeparatedList(Argument(IdentifierName(p.Name)))
                                        )
                                    )
                                )
                            )
                        )
                    ),
                    MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        ThisExpression(),
                        IdentifierName(p.Name)
                    )
                )
            ).ToArray();

        var dictionaryCreation = ObjectCreationExpression(
            GenericName(
                Identifier(DictionaryType),
                TypeArgumentList(
                    SeparatedList<TypeSyntax>(
                        [
                            PredefinedType(Token(SyntaxKind.StringKeyword)),
                            NullableType(PredefinedType(Token(SyntaxKind.ObjectKeyword)))
                        ]
                    )
                )
            ), ArgumentList(SeparatedList<ArgumentSyntax>()),
            InitializerExpression(SyntaxKind.ObjectInitializerExpression,
                SeparatedList<ExpressionSyntax>(assignmentExpressions))
        );

        var returnStatement = ReturnStatement(dictionaryCreation);

        var method = MethodDeclaration(
                GenericName(
                    Identifier(IDictionaryType),
                    TypeArgumentList(SeparatedList<TypeSyntax>([
                        PredefinedType(Token(SyntaxKind.StringKeyword)),
                        NullableType(PredefinedType(Token(SyntaxKind.ObjectKeyword)))
                    ]))
                ),
                Identifier(ToDictionaryName)
            ).WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
            .WithBody(Block(returnStatement));
        return method;
    }

    private static MethodDeclarationSyntax FromDictionaryMethodDeclaration(NavDestinationInfo info)
    {
        var qualifiedName = info.GetArgsClassName();

        BlockSyntax body;

        if (true || info.Mode == GenerationMode.Strict) // TODO: Enable use of FlexibleMode
            body = StrictFromDictionaryMethodBodyDeclaration(qualifiedName, info.Properties);
        else
            body = FlexibleFromDictionaryMethodBodyDeclaration(qualifiedName, info.Properties);

        var parameters =
            ParameterList(
                SingletonSeparatedList(
                    Parameter(Identifier(DictionaryVariable))
                        .WithType(
                            GenericName(
                                Identifier(IDictionaryType),
                                TypeArgumentList(SeparatedList<TypeSyntax>([
                                    PredefinedType(Token(SyntaxKind.StringKeyword)),
                                    PredefinedType(Token(SyntaxKind.ObjectKeyword))
                                ]))
                            )
                        )
                )
            );

        return MethodDeclaration(ParseTypeName(qualifiedName), Identifier(FromDictionaryName))
            .WithModifiers(TokenList(
                Token(SyntaxKind.PublicKeyword),
                Token(SyntaxKind.StaticKeyword)
            ))
            .WithParameterList(parameters)
            .WithBody(body);
    }

    private static BlockSyntax FlexibleFromDictionaryMethodBodyDeclaration(string qualifiedName,
        ImmutableArray<PropertyInfo> properties)
    {
        throw new NotImplementedException("Flexible flexible dictionary methods are not yet implemented");
    }

    private static BlockSyntax StrictFromDictionaryMethodBodyDeclaration(string qualifiedName,
        ImmutableArray<PropertyInfo> properties)
    {
        var instanceCreation = ArgsInstanceCreation(qualifiedName,
            SeparatedList(properties.Select(p => Argument(IdentifierName($"v{p.Name}")))));
        var declarations = properties.Select(VarDeclaration);
        var body = Block(declarations.Append(ReturnStatement(instanceCreation)));

        return body;

        // var v = (type)dict[key];
        StatementSyntax VarDeclaration(PropertyInfo property)
        {
            var dictExtraction = DictionaryAccess(IdentifierName(DictionaryVariable), Argument(InvocationExpression(
                IdentifierName("nameof"),
                ArgumentList(SingletonSeparatedList(Argument(IdentifierName(property.Name)))))));
            // cast
            ExpressionSyntax cast;
            if (property.IsNullable)
                cast = BinaryExpression(SyntaxKind.AsExpression,
                    dictExtraction,
                    ParseTypeName(property.TypeAs));
            else
                cast = CastExpression(
                    ParseTypeName(property.TypeCast),
                    dictExtraction);

            var declaration = LocalDeclarationStatement(
                VariableDeclaration(IdentifierName("var"))
                    .AddVariables(VariableDeclarator($"v{property.Name}")
                        .WithInitializer(EqualsValueClause(cast)
                        )
                    )
            );

            return declaration;
        }
    }

    // dict[argument]
    private static ExpressionSyntax DictionaryAccess(IdentifierNameSyntax dictionaryIdentifier,
        ArgumentSyntax argument)
    {
        return ElementAccessExpression(dictionaryIdentifier, BracketedArgumentList(SingletonSeparatedList(argument)));
    }

    private static ObjectCreationExpressionSyntax ArgsInstanceCreation(string instanceType,
        SeparatedSyntaxList<ArgumentSyntax> arguments)
    {
        var objectCreation = ObjectCreationExpression(
            ParseTypeName(instanceType),
            ArgumentList(arguments),
            null);

        return objectCreation;
    }

    private static ExpressionSyntax DictionaryAccessAndCastArgument(PropertyInfo property)
    {
        // dictionary[nameof(propertyName)]
        var dictionaryAccess = ElementAccessExpression(IdentifierName(DictionaryVariable),
            BracketedArgumentList(
                SingletonSeparatedList(
                    Argument(InvocationExpression(
                            IdentifierName("nameof"),
                            ArgumentList(SingletonSeparatedList(Argument(IdentifierName(property.Name))))
                        )
                    )
                )
            ));

        // Convert.ChangeType(dictionaryAccess, typeof(type))
        var invocation = InvocationExpression(
            MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                IdentifierName(nameof(Convert)),
                IdentifierName(nameof(Convert.ChangeType))
            ),
            ArgumentList(
                SeparatedList<ArgumentSyntax>([
                    Argument(dictionaryAccess),
                    Argument(TypeOfExpression(ParseTypeName(property.Type.Replace('?', ' '))))
                ])
            ));

        // (type)invocation
        var cast = CastExpression(
            ParseTypeName(property.Type.Replace('?', ' ')),
            invocation);

        return cast;
    }

    private static MethodDeclarationSyntax GetArgsMethodDeclaration(NavDestinationInfo info)
    {
        var arguments = SeparatedList(
            info.Properties.Select(p =>
                Argument(
                    IdentifierName(p.Name)
                    // MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                    //     ThisExpression(),
                    //     IdentifierName(p.Name))
                )
            ));
        var argsCreation = ArgsInstanceCreation(info.GetArgsClassName(), arguments);

        var returnStatement = ReturnStatement(argsCreation);
        var method = MethodDeclaration(ParseTypeName(ArgsInterfaceName), Identifier(GetArgsName))
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
            .WithBody(Block(returnStatement));
        return method;
    }

    private static PropertyDeclarationSyntax RoutePropertyDeclaration(string route)
    {
        return PropertyDeclaration(PredefinedType(Token(SyntaxKind.StringKeyword)), Identifier("Route"))
            .AddModifiers(Token(SyntaxKind.PublicKeyword))
            .WithExpressionBody(
                ArrowExpressionClause(Token(SyntaxKind.EqualsGreaterThanToken),
                    LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(route))
                )
            ).WithSemicolonToken(Token(SyntaxKind.SemicolonToken));
    }

    [GeneratedCode("tool", "version")]
    private static AttributeSyntax GeneratorAttribute()
    {
        return Attribute(ParseName("global::System.CodeDom.Compiler.GeneratedCode"),
            AttributeArgumentList(
                SeparatedList<AttributeArgumentSyntax>([
                    AttributeArgument(LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(CodeGenName))),
                    AttributeArgument(LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(CodeGenVersion)))
                ])
            ));
    }

    private static AttributeListSyntax GetAttributesList(params AttributeSyntax[] attributes)
    {
        return AttributeList(SeparatedList(attributes));
    }
}