using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using static NavArgs.Abstractions.Constants;

namespace NavArgs.Abstractions.Models;

internal partial record NavDestinationInfo
{
    private const string FromDictionaryName = "FromDictionary";
    private const string ToDictionaryName = "ToDictionary";
    private const string GetArgsName = "GetArgs";
    private const string DictionaryVariable = "dictionary";

    // ReSharper disable once InconsistentNaming
    private const string IDictionaryType = "IDictionary";
    private const string DictionaryType = "Dictionary";
    // private const string InstanceVariable = "instance";
    private const string AutoGenerated = "// <auto-generated/>";

    public CompilationUnitSyntax GetCompilationUnit()
    {
        var usingsDeclaration = List<UsingDirectiveSyntax>([
            UsingDirective(ParseName("System")),
            UsingDirective(ParseName("System.Collections.Generic")),
            UsingDirective(ParseName(Constants.Namespace)),
        ]);

        MemberDeclarationSyntax[] classDeclarations =
        [
            PartialClassDeclaration(this),
            ArgsRecordDeclaration(this)
        ];

        MemberDeclarationSyntax[] members;
        if (string.IsNullOrEmpty(Namespace))
        {
            members = classDeclarations;
        }
        else
        {
            members =
            [
                NamespaceDeclaration(IdentifierName(Namespace))
                    .AddMembers(classDeclarations)
            ];
        }

        return CompilationUnit()
            .WithUsings(usingsDeclaration)
            .AddMembers(members)
            .WithLeadingTrivia(TriviaList(
                Comment(AutoGenerated),
                Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true))
            ))
            .NormalizeWhitespace();
    }

    private static ClassDeclarationSyntax PartialClassDeclaration(NavDestinationInfo info)
    {
        MemberDeclarationSyntax[] membersList;
        var useRoute = !string.IsNullOrWhiteSpace(info.Route);
        if (useRoute)
        {
            membersList =
            [
                RoutePropertyDeclaration(info.Route!),
                GetArgsMethodDeclaration(info),
                ToDictionaryMethodDeclaration(info.Properties),
            ];
        }
        else
        {
            membersList =
            [
                GetArgsMethodDeclaration(info),
                ToDictionaryMethodDeclaration(info.Properties),
            ];
        }

        var members = List(membersList);

        if (useRoute)
        {
            members.Add(RoutePropertyDeclaration(info.Route!));
        }

        return ClassDeclaration(info.QualifiedName)
            .WithMembers(members)
            .WithModifiers(TokenList(
                Token(SyntaxKind.PartialKeyword)
            ));
    }

    private static RecordDeclarationSyntax ArgsRecordDeclaration(NavDestinationInfo info)
    {
        var qualifiedName = info.GetArgsClassName();
        
        var baseTypes = BaseList(SeparatedList<BaseTypeSyntax>(
        [
            SimpleBaseType(ParseTypeName(ArgsInterfaceName))
        ]));

        MemberDeclarationSyntax[] methodsDeclaration =
        [
            FromDictionaryMethodDeclaration(qualifiedName, info.Properties),
            // ToDictionaryMethodDeclaration(info.Properties),
        ];

        var parametersList = ParameterList(
            SeparatedList(info.Properties.Select(p =>
                Parameter(Identifier(p.Name)).WithType(ParseTypeName(p.Type)))));

        var recordDeclaration =
            RecordDeclaration(Token(SyntaxKind.RecordKeyword), Identifier(qualifiedName))
                .WithBaseList(baseTypes)
                .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
                .WithParameterList(parametersList)
                .WithMembers(List(methodsDeclaration))
                .WithOpenBraceToken(Token(SyntaxKind.OpenBraceToken))
                .WithCloseBraceToken(Token(SyntaxKind.CloseBraceToken))
                .WithLeadingTrivia(TriviaList(Comment(AutoGenerated)))
                .NormalizeWhitespace();

        return recordDeclaration;
    }

    private static MethodDeclarationSyntax ToDictionaryMethodDeclaration(ImmutableArray<PropertyInfo> properties)
    {
        var assignmentExpressions =
            properties.Select(p => AssignmentExpression(
                    SyntaxKind.SimpleAssignmentExpression,
                    left: ImplicitElementAccess(
                        BracketedArgumentList(
                            SingletonSeparatedList(
                                Argument(InvocationExpression(
                                        IdentifierName("nameof"),
                                        ArgumentList(
                                            SingletonSeparatedList(Argument(IdentifierName(p.Name)))
                                        )
                                    )
                                )
                            )
                        )
                    ),
                    right: MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        ThisExpression(),
                        IdentifierName(p.Name)
                    )
                )
            ).ToArray();

        var dictionaryCreation = ObjectCreationExpression(
            GenericName(
                Identifier(DictionaryType),
                TypeArgumentList(
                    SeparatedList<TypeSyntax>(
                        [
                            PredefinedType(Token(SyntaxKind.StringKeyword)),
                            NullableType(PredefinedType(Token(SyntaxKind.ObjectKeyword))),
                        ]
                    )
                )
            ), ArgumentList(SeparatedList<ArgumentSyntax>()),
            InitializerExpression(SyntaxKind.ObjectInitializerExpression,
                SeparatedList<ExpressionSyntax>(assignmentExpressions))
        );

        var returnStatement = ReturnStatement(dictionaryCreation);

        var method = MethodDeclaration(
                GenericName(
                    Identifier(IDictionaryType),
                    TypeArgumentList(SeparatedList<TypeSyntax>([
                        PredefinedType(Token(SyntaxKind.StringKeyword)),
                        NullableType(PredefinedType(Token(SyntaxKind.ObjectKeyword)))
                    ]))
                ),
                Identifier(ToDictionaryName)
            ).WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
            .WithBody(Block(returnStatement));
        return method;
    }

    // private static PropertyDeclarationSyntax GetPropertyDeclaration(PropertyInfo property)
    // {
    //     return PropertyDeclaration(ParseTypeName(property.Type), Identifier(property.Name))
    //         .AddModifiers(Token(SyntaxKind.PublicKeyword))
    //         .AddAccessorListAccessors(
    //             AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
    //                 .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)),
    //             AccessorDeclaration(SyntaxKind.InitAccessorDeclaration)
    //                 .WithSemicolonToken(Token(SyntaxKind.SemicolonToken))
    //             // AccessorDeclaration(SyntaxKind.SetAccessorDeclaration)
    //             //     .AddModifiers(Token(SyntaxKind.PrivateKeyword))
    //             //     .WithSemicolonToken(Token(SyntaxKind.SemicolonToken))
    //         );
    // }

    /*
 void FromDictionary(IDictionary<string, object> dictionary)
 {
     return new NavArgs(dictionary[nameof(Property)]);
 }
 */
    private static MethodDeclarationSyntax FromDictionaryMethodDeclaration(string instanceType,
        ImmutableArray<PropertyInfo> properties)
    {
        var arguments = SeparatedList(
            properties.Select(p => Argument(DictionaryAccessAndCastArgument(p)))
        );
        var instanceCreation = ArgsInstanceCreation(instanceType, arguments);
        var returnStatement = ReturnStatement(instanceCreation);

        var parameters =
            ParameterList(
                SingletonSeparatedList(
                    Parameter(Identifier(DictionaryVariable))
                        .WithType(
                            GenericName(
                                Identifier(IDictionaryType),
                                TypeArgumentList(SeparatedList<TypeSyntax>([
                                    PredefinedType(Token(SyntaxKind.StringKeyword)),
                                    PredefinedType(Token(SyntaxKind.ObjectKeyword))
                                ]))
                            )
                        )
                )
            );

        return MethodDeclaration(ParseTypeName(instanceType), Identifier(FromDictionaryName))
            .WithModifiers(TokenList(
                Token(SyntaxKind.PublicKeyword),
                Token(SyntaxKind.StaticKeyword)
            ))
            .WithParameterList(parameters)
            .WithBody(Block(returnStatement));
    }

    private static ObjectCreationExpressionSyntax ArgsInstanceCreation(string instanceType,
        SeparatedSyntaxList<ArgumentSyntax> arguments)
    {
        var objectCreation = ObjectCreationExpression(
            type: ParseTypeName(instanceType),
            argumentList: ArgumentList(arguments),
            initializer: null);

        return objectCreation;
    }

    private static ExpressionSyntax DictionaryAccessAndCastArgument(PropertyInfo property)
    {
        // dictionary[nameof(propertyName)]
        var dictionaryAccess = ElementAccessExpression(IdentifierName(DictionaryVariable),
            BracketedArgumentList(
                SingletonSeparatedList(
                    Argument(InvocationExpression(
                            IdentifierName("nameof"),
                            ArgumentList(SingletonSeparatedList(Argument(IdentifierName(property.Name))))
                        )
                    )
                )
            ));

        // Convert.ChangeType(dictionaryAccess, typeof(type))
        var invocation = InvocationExpression(
            MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                IdentifierName(nameof(Convert)),
                IdentifierName(nameof(Convert.ChangeType))
            ),
            ArgumentList(
                SeparatedList<ArgumentSyntax>([
                    Argument(dictionaryAccess),
                    Argument(TypeOfExpression(ParseTypeName(property.Type.Replace('?', ' '))))
                ])
            ));

        // (type)invocation
        var cast = CastExpression(
            type: ParseTypeName(property.Type.Replace('?', ' ')),
            expression: invocation);

        return cast;
    }

    // /// <summary>
    // /// 
    // /// </summary>
    // /// <param name="property"></param>
    // /// <returns></returns>
    // /// <remarks>
    // ///     <code>
    // ///         property = (type)Convert.ChangeType(Dictionary[nameof(property)], typeof(type))
    // ///     </code>
    // /// </remarks>
    // [Obsolete]
    // private static AssignmentExpressionSyntax InstancePropertyExtractionStatement(PropertyInfo property)
    // {
    //     var cast = DictionaryAccessAndCastArgument(property);
    //
    //     var assignment = AssignmentExpression(SyntaxKind.SimpleAssignmentExpression,
    //         left: IdentifierName(property.Name),
    //         right: cast
    //     );
    //
    //     return assignment;
    // }
    // [Obsolete]
    // private static MethodDeclarationSyntax FromDictionaryMethodIfDeclaration(string instanceType,
    //     ImmutableArray<PropertyInfo> properties)
    // {
    //     var body = Block(new StatementSyntax[]
    //         {
    //             InstanceDeclarationStatement(instanceType)
    //         }
    //         .Concat(properties.Select(InstancePropertyExtractionIfStatement))
    //         .Append(ReturnStatement(IdentifierName(InstanceVariable)))
    //     );
    //     var parameters =
    //         ParameterList(
    //             SingletonSeparatedList(
    //                 Parameter(Identifier(DictionaryVariable))
    //                     .WithType(
    //                         GenericName(
    //                             Identifier(DictionaryType),
    //                             TypeArgumentList(SeparatedList<TypeSyntax>([
    //                                 PredefinedType(Token(SyntaxKind.StringKeyword)),
    //                                 PredefinedType(Token(SyntaxKind.ObjectKeyword))
    //                             ]))
    //                         )
    //                     )
    //             )
    //         );
    //
    //     var method = MethodDeclaration(ParseTypeName($"{instanceType}Args"), Identifier(FromDictionaryName))
    //         .AddModifiers(
    //             Token(SyntaxKind.PublicKeyword),
    //             Token(SyntaxKind.StaticKeyword))
    //         .WithParameterList(parameters)
    //         .WithBody(body);
    //
    //     return method;
    // }

    // /// <summary>
    // /// 
    // /// </summary>
    // /// <param name="property"></param>
    // /// <returns></returns>
    // /// <remarks>
    // ///     <code>
    // ///         if (dictionary.TryGetValue(property, out var value) && value != null)
    // ///         {
    // ///             instance.property = (type)Convert.ChangeType(value, typeof(type));
    // ///         }
    // ///     </code>
    // /// </remarks>
    // private static StatementSyntax InstancePropertyExtractionIfStatement(PropertyInfo property)
    // {
    //     // (type)Convert.ChangeType(value, typeof(type))
    //     var cast = CastExpression(
    //         type: ParseTypeName(property.Type.Replace('?', ' ')),
    //         expression: InvocationExpression(
    //             MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
    //                 IdentifierName(nameof(Convert)),
    //                 IdentifierName(nameof(Convert.ChangeType))
    //             ),
    //             ArgumentList(
    //                 SeparatedList<ArgumentSyntax>([
    //                     Argument(IdentifierName($"value{property.Name}")),
    //                     Argument(TypeOfExpression(ParseTypeName(property.Type.Replace('?', ' '))))
    //                 ])
    //             )
    //         )
    //     );
    //     // instance.property = cast
    //     var assignment = AssignmentExpression(SyntaxKind.SimpleAssignmentExpression,
    //         left: MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
    //             IdentifierName(InstanceVariable),
    //             IdentifierName(property.Name)
    //         ),
    //         right: cast
    //     );
    //
    //     // dictionary.TryGetValue(nameof(property), out var value) && value != null
    //     var condition = BinaryExpression(SyntaxKind.LogicalAndExpression,
    //         left: InvocationExpression(
    //             MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
    //                 IdentifierName(DictionaryVariable),
    //                 IdentifierName("TryGetValue")
    //             ),
    //             ArgumentList(
    //                 SeparatedList<ArgumentSyntax>(
    //                     [
    //                         Argument(InvocationExpression(
    //                             IdentifierName("nameof"),
    //                             ArgumentList(SingletonSeparatedList(Argument(IdentifierName(property.Name))))
    //                         )),
    //                         Argument(
    //                             DeclarationExpression(
    //                                 ParseTypeName("var"),
    //                                 SingleVariableDesignation(Identifier($"value{property.Name}"))
    //                             )
    //                         ).WithRefKindKeyword(Token(SyntaxKind.OutKeyword))
    //                     ]
    //                 )
    //             )),
    //         right: BinaryExpression(SyntaxKind.NotEqualsExpression,
    //             left: IdentifierName($"value{property.Name}"),
    //             right: LiteralExpression(SyntaxKind.NullLiteralExpression)
    //         )
    //     );
    //
    //     var conditional = IfStatement(
    //         condition,
    //         Block(ExpressionStatement(assignment))
    //     );
    //
    //     return conditional;
    // }

    // private static LocalDeclarationStatementSyntax InstanceDeclarationStatement(string instanceType)
    // {
    //     return
    //         LocalDeclarationStatement(
    //             VariableDeclaration(IdentifierName("var"))
    //                 .AddVariables(
    //                     VariableDeclarator(InstanceVariable)
    //                         .WithInitializer(
    //                             EqualsValueClause(
    //                                 ObjectCreationExpression(ParseTypeName($"{instanceType}Args"))
    //                                     .WithArgumentList(ArgumentList())
    //                             )
    //                         )
    //                 )
    //         );
    // }

    private static MethodDeclarationSyntax GetArgsMethodDeclaration(NavDestinationInfo info)
    {
        var arguments = SeparatedList(
            info.Properties.Select(p =>
                Argument(
                    IdentifierName(p.Name)
                    // MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                    //     ThisExpression(),
                    //     IdentifierName(p.Name))
                )
            ));
        var argsCreation = ArgsInstanceCreation(info.GetArgsClassName(), arguments);

        var returnStatement = ReturnStatement(argsCreation);
        var method = MethodDeclaration(ParseTypeName(ArgsInterfaceName), Identifier(GetArgsName))
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
            .WithBody(Block(returnStatement));
        return method;
    }

    private static PropertyDeclarationSyntax RoutePropertyDeclaration(string route)
    {
        return PropertyDeclaration(PredefinedType(Token(SyntaxKind.StringKeyword)), Identifier("Route"))
            .AddModifiers(Token(SyntaxKind.PublicKeyword))
            .WithExpressionBody(
                ArrowExpressionClause(Token(SyntaxKind.EqualsGreaterThanToken),
                    LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(route))
                )
            ).WithSemicolonToken(Token(SyntaxKind.SemicolonToken));
    }
}