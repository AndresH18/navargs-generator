using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using static NavArgs.Generator.Constants;

namespace NavArgs.Generator.Models;

internal partial record NavDestinationInfo
{
    private const string FromDictionaryName = "FromDictionary";
    private const string ToDictionaryName = "ToDictionary";
    private const string DictionaryVariable = "dictionary";
    private const string InstanceVariable = "instance";
    private const string AutoGenerated = "// <auto-generated/>";

    public CompilationUnitSyntax GetCompilationUnit()
    {
        var usingsDeclaration = List<UsingDirectiveSyntax>([
            UsingDirective(ParseName("System")),
            UsingDirective(ParseName("System.Collections.Generic")),
            UsingDirective(ParseName(Constants.Namespace)),
        ]);

        MemberDeclarationSyntax[] classDeclarations =
        [
            PartialClassDeclaration(this),
            ArgsClassDeclaration(this)
        ];

        MemberDeclarationSyntax[] members;
        if (string.IsNullOrEmpty(Namespace))
        {
            members = classDeclarations;
        }
        else
        {
            members =
            [
                NamespaceDeclaration(IdentifierName(Namespace))
                    .AddMembers(classDeclarations)
            ];
        }

        return CompilationUnit()
            .WithUsings(usingsDeclaration)
            .AddMembers(members)
            .WithLeadingTrivia(TriviaList(
                Comment(AutoGenerated),
                Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true))
            ))
            .NormalizeWhitespace();
    }

    private static ClassDeclarationSyntax PartialClassDeclaration(NavDestinationInfo info)
    {
        MemberDeclarationSyntax[] membersList;
        if (info.Route != null)
        {
            membersList =
            [
                RoutePropertyDeclaration(info.Route),
                GetArgsMethodDeclaration(info)
            ];
        }
        else
        {
            membersList = [GetArgsMethodDeclaration(info)];
        }

        var members = List(membersList);

        if (info.Route != null)
        {
            members.Add(RoutePropertyDeclaration(info.Route));
        }

        return ClassDeclaration(info.QualifiedName)
            // .WithBaseList(BaseList(SeparatedList<BaseTypeSyntax>([
            //         SimpleBaseType(ParseTypeName(NavInterfaceName))
            //     ]))
            // )
            .WithMembers(members)
            .WithModifiers(TokenList(
                Token(SyntaxKind.PartialKeyword)
            ));
    }

    private static ClassDeclarationSyntax ArgsClassDeclaration(NavDestinationInfo info)
    {
        var baseTypes = BaseList(SeparatedList<BaseTypeSyntax>(
        [
            SimpleBaseType(ParseTypeName(ArgsInterfaceName))
        ]));

        MemberDeclarationSyntax[] propertiesDeclaration =
            info.Properties.Select(GetPropertyDeclaration).ToArray<MemberDeclarationSyntax>();
        MemberDeclarationSyntax[] methodsDeclaration =
        [
            FromDictionaryMethodDeclaration(info.QualifiedName, info.Properties),
            ToDictionaryMethodDeclaration(info.Properties),
        ];

        MemberDeclarationSyntax[] classMembers = propertiesDeclaration.Concat(methodsDeclaration).ToArray();

        var classDeclaration = ClassDeclaration(Identifier($"{info.QualifiedName}Args"))
            .WithModifiers(TokenList(
                Token(SyntaxKind.PublicKeyword),
                Token(SyntaxKind.SealedKeyword)
            ))
            .WithBaseList(baseTypes)
            .WithMembers(List(classMembers))
            .WithLeadingTrivia(TriviaList(Comment(AutoGenerated)))
            .NormalizeWhitespace();
        return classDeclaration;
    }

    private static MethodDeclarationSyntax ToDictionaryMethodDeclaration(ImmutableArray<PropertyInfo> properties)
    {
        var assignmentExpressions =
            properties.Select(p => AssignmentExpression(
                    SyntaxKind.SimpleAssignmentExpression,
                    left: ImplicitElementAccess(
                        BracketedArgumentList(
                            SingletonSeparatedList(
                                Argument(InvocationExpression(
                                        IdentifierName("nameof"),
                                        ArgumentList(
                                            SingletonSeparatedList(Argument(IdentifierName(p.Name)))
                                        )
                                    )
                                )
                            )
                        )
                    ),
                    right: MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        ThisExpression(),
                        IdentifierName(p.Name)
                    )
                )
            ).ToArray();

        var dictionaryCreation = ObjectCreationExpression(
            GenericName(
                Identifier("Dictionary"),
                TypeArgumentList(
                    SeparatedList<TypeSyntax>(
                        [
                            PredefinedType(Token(SyntaxKind.StringKeyword)),
                            NullableType(PredefinedType(Token(SyntaxKind.ObjectKeyword))),
                        ]
                    )
                )
            ), ArgumentList(SeparatedList<ArgumentSyntax>()),
            InitializerExpression(SyntaxKind.ObjectInitializerExpression,
                SeparatedList<ExpressionSyntax>(assignmentExpressions))
        );

        var returnStatement = ReturnStatement(dictionaryCreation);

        var method = MethodDeclaration(
                GenericName(
                    Identifier("IDictionary"),
                    TypeArgumentList(SeparatedList<TypeSyntax>([
                        PredefinedType(Token(SyntaxKind.StringKeyword)),
                        NullableType(PredefinedType(Token(SyntaxKind.ObjectKeyword)))
                    ]))
                ),
                Identifier(ToDictionaryName)
            ).WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
            .WithBody(Block(returnStatement));
        return method;
    }

    private static PropertyDeclarationSyntax GetPropertyDeclaration(PropertyInfo property)
    {
        return PropertyDeclaration(ParseTypeName(property.Type), Identifier(property.Name))
            .AddModifiers(Token(SyntaxKind.PublicKeyword))
            .AddAccessorListAccessors(
                AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                    .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)),
                AccessorDeclaration(SyntaxKind.InitAccessorDeclaration)
                    .WithSemicolonToken(Token(SyntaxKind.SemicolonToken))
                // AccessorDeclaration(SyntaxKind.SetAccessorDeclaration)
                //     .AddModifiers(Token(SyntaxKind.PrivateKeyword))
                //     .WithSemicolonToken(Token(SyntaxKind.SemicolonToken))
            );
    }

    /*
 void FromDictionary(IDictionary<string, object> dictionary)
 {
     return new NavArgs
     {
         Property = dictionary[nameof(Property)],
     }
 }
 */
    private static MethodDeclarationSyntax FromDictionaryMethodDeclaration(string instanceType,
        ImmutableArray<PropertyInfo> properties)
    {
        var initializerList = SeparatedList<ExpressionSyntax>(properties.Select(InstancePropertyExtractionStatement));
        var objectCreation = ObjectCreationExpression(
            type: ParseTypeName($"{instanceType}Args"),
            argumentList: ArgumentList(),
            initializer: InitializerExpression(SyntaxKind.ObjectInitializerExpression, initializerList));

        var returnStatement = ReturnStatement(objectCreation);

        var parameters =
            ParameterList(
                SingletonSeparatedList(
                    Parameter(Identifier(DictionaryVariable))
                        .WithType(
                            GenericName(
                                Identifier("Dictionary"),
                                TypeArgumentList(SeparatedList<TypeSyntax>([
                                    PredefinedType(Token(SyntaxKind.StringKeyword)),
                                    PredefinedType(Token(SyntaxKind.ObjectKeyword))
                                ]))
                            )
                        )
                )
            );

        return MethodDeclaration(ParseTypeName($"{instanceType}Args"), Identifier(FromDictionaryName))
            .WithModifiers(TokenList(
                Token(SyntaxKind.PublicKeyword),
                Token(SyntaxKind.StaticKeyword)
            ))
            .WithParameterList(parameters)
            .WithBody(Block(returnStatement));
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="property"></param>
    /// <returns></returns>
    /// <remarks>
    ///     <code>
    ///         property = (type)Convert.ChangeType(Dictionary[nameof(property)], typeof(type))
    ///     </code>
    /// </remarks>
    private static AssignmentExpressionSyntax InstancePropertyExtractionStatement(PropertyInfo property)
    {
        var dictionaryAccess = ElementAccessExpression(IdentifierName(DictionaryVariable),
            BracketedArgumentList(
                SingletonSeparatedList(
                    Argument(InvocationExpression(
                            IdentifierName("nameof"),
                            ArgumentList(SingletonSeparatedList(Argument(IdentifierName(property.Name))))
                        )
                    )
                )
            ));

        var invocation = InvocationExpression(
            MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                IdentifierName(nameof(Convert)),
                IdentifierName(nameof(Convert.ChangeType))
            ),
            ArgumentList(
                SeparatedList<ArgumentSyntax>([
                    Argument(dictionaryAccess),
                    Argument(TypeOfExpression(ParseTypeName(property.Type.Replace('?', ' '))))
                ])
            ));

        var cast = CastExpression(
            type: ParseTypeName(property.Type.Replace('?', ' ')),
            expression: invocation);

        var assignment = AssignmentExpression(SyntaxKind.SimpleAssignmentExpression,
            left: IdentifierName(property.Name),
            right: cast
        );

        return assignment;
    }


    private static MethodDeclarationSyntax FromDictionaryMethodIfDeclaration(string instanceType,
        ImmutableArray<PropertyInfo> properties)
    {
        var body = Block(new StatementSyntax[]
            {
                InstanceDeclarationStatement(instanceType)
            }
            .Concat(properties.Select(InstancePropertyExtractionIfStatement))
            .Append(ReturnStatement(IdentifierName(InstanceVariable)))
        );
        var parameters =
            ParameterList(
                SingletonSeparatedList(
                    Parameter(Identifier(DictionaryVariable))
                        .WithType(
                            GenericName(
                                Identifier("Dictionary"),
                                TypeArgumentList(SeparatedList<TypeSyntax>([
                                    PredefinedType(Token(SyntaxKind.StringKeyword)),
                                    PredefinedType(Token(SyntaxKind.ObjectKeyword))
                                ]))
                            )
                        )
                )
            );

        var method = MethodDeclaration(ParseTypeName($"{instanceType}Args"), Identifier(FromDictionaryName))
            .AddModifiers(
                Token(SyntaxKind.PublicKeyword),
                Token(SyntaxKind.StaticKeyword))
            .WithParameterList(parameters)
            .WithBody(body);

        return method;
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="property"></param>
    /// <returns></returns>
    /// <remarks>
    ///     <code>
    ///         if (dictionary.TryGetValue(property, out var value) && value != null)
    ///         {
    ///             instance.property = (type)Convert.ChangeType(value, typeof(type));
    ///         }
    ///     </code>
    /// </remarks>
    private static StatementSyntax InstancePropertyExtractionIfStatement(PropertyInfo property)
    {
        // (type)Convert.ChangeType(value, typeof(type))
        var cast = CastExpression(
            type: ParseTypeName(property.Type.Replace('?', ' ')),
            expression: InvocationExpression(
                MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName(nameof(Convert)),
                    IdentifierName(nameof(Convert.ChangeType))
                ),
                ArgumentList(
                    SeparatedList<ArgumentSyntax>([
                        Argument(IdentifierName($"value{property.Name}")),
                        Argument(TypeOfExpression(ParseTypeName(property.Type.Replace('?', ' '))))
                    ])
                )
            )
        );
        // instance.property = cast
        var assignment = AssignmentExpression(SyntaxKind.SimpleAssignmentExpression,
            left: MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                IdentifierName(InstanceVariable),
                IdentifierName(property.Name)
            ),
            right: cast
        );

        // dictionary.TryGetValue(nameof(property), out var value) && value != null
        var condition = BinaryExpression(SyntaxKind.LogicalAndExpression,
            left: InvocationExpression(
                MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName(DictionaryVariable),
                    IdentifierName("TryGetValue")
                ),
                ArgumentList(
                    SeparatedList<ArgumentSyntax>(
                        [
                            Argument(InvocationExpression(
                                IdentifierName("nameof"),
                                ArgumentList(SingletonSeparatedList(Argument(IdentifierName(property.Name))))
                            )),
                            Argument(
                                DeclarationExpression(
                                    ParseTypeName("var"),
                                    SingleVariableDesignation(Identifier($"value{property.Name}"))
                                )
                            ).WithRefKindKeyword(Token(SyntaxKind.OutKeyword))
                        ]
                    )
                )),
            right: BinaryExpression(SyntaxKind.NotEqualsExpression,
                left: IdentifierName($"value{property.Name}"),
                right: LiteralExpression(SyntaxKind.NullLiteralExpression)
            )
        );

        var conditional = IfStatement(
            condition,
            Block(ExpressionStatement(assignment))
        );

        return conditional;
    }

    private static LocalDeclarationStatementSyntax InstanceDeclarationStatement(string instanceType)
    {
        return
            LocalDeclarationStatement(
                VariableDeclaration(IdentifierName("var"))
                    .AddVariables(
                        VariableDeclarator(InstanceVariable)
                            .WithInitializer(
                                EqualsValueClause(
                                    ObjectCreationExpression(ParseTypeName($"{instanceType}Args"))
                                        .WithArgumentList(ArgumentList())
                                )
                            )
                    )
            );
    }

    private static MethodDeclarationSyntax GetArgsMethodDeclaration(NavDestinationInfo info)
    {
        var initializationList = SeparatedList<ExpressionSyntax>(info.Properties.Select(p =>
            AssignmentExpression(
                SyntaxKind.SimpleAssignmentExpression,
                left: IdentifierName(p.Name),
                right: MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                    ThisExpression(),
                    IdentifierName(p.Name))
            )
        ));

        var objectCreation = ObjectCreationExpression(
            ParseTypeName($"{info.QualifiedName}Args"),
            ArgumentList(),
            InitializerExpression(SyntaxKind.ObjectInitializerExpression, initializationList));

        var returnStatement = ReturnStatement(objectCreation);
        var method = MethodDeclaration(ParseTypeName(ArgsInterfaceName), Identifier("GetArgs"))
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
            .WithBody(Block(returnStatement));
        return method;
    }

    private static PropertyDeclarationSyntax RoutePropertyDeclaration(string route)
    {
        return PropertyDeclaration(PredefinedType(Token(SyntaxKind.StringKeyword)), Identifier("Route"))
            .AddModifiers(Token(SyntaxKind.PublicKeyword))
            .WithExpressionBody(
                ArrowExpressionClause(Token(SyntaxKind.EqualsGreaterThanToken),
                    LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(route))
                )
            ).WithSemicolonToken(Token(SyntaxKind.SemicolonToken));
    }
}